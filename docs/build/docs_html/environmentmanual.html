<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NAWA: Environment</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NAWA
   &#160;<span id="projectnumber">0.8</span>
   </div>
   <div id="projectbrief">Web Application Framework for C++</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('environmentmanual.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Environment </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_docs_environment"></a></p>
<p>The <code><a class="el" href="classnawa_1_1Request.html">nawa::Request</a></code> object <code>connection.request()</code> (which can be accessed through <code>connection</code>, the <code><a class="el" href="classnawa_1_1Connection.html">nawa::Connection</a></code> object you get as a parameter of your <code>handleRequest</code> function) allows you to access information about the request (such as POST, GET, and COOKIE data) and the environment.</p>
<p>This manual page will also show you how to set cookies, HTTP headers, and the HTTP status.</p>
<h1>Request Path and environment</h1>
<p>The request path is probably the most important information you want to access in your application, as it allows you to respond with the correct page. The function <code>nawa::Request::Env::getRequestPath()</code>, accessible as <code>connection.request().env().getRequestPath()</code>, returns a vector of strings containing all elements of the request URI (without query string).</p>
<p>If the user requested the URI "/dir1/dir2/page", the vector would contain the elements {"dir1", "dir2", "page"}.</p>
<p>For an example concerning the usage of the request path, see <code><a class="el" href="multipage_8cpp.html" title="A simple website consisting of multiple &#39;dynamic&#39; pages and virtual directories for html files and im...">examples/multipage.cpp</a></code>.</p>
<p>Other environment variables and request headers can be accessed as strings by using the <code>[]</code> operator. For example, to access the server hostname, use <code>connection.request().env()["host"]</code>. In the following section, you'll find the full list of environment variables that can be accessed this way.</p>
<h2>List of environment variables</h2>
<p>All of the following environment variables are available in the FastCGI request handler. All except for those marked with (*) are also available in the HTTP request handler.</p>
<ul>
<li><code>DOCUMENT_ROOT</code>: HTTP root directory (*)</li>
<li><code>SCRIPT_NAME</code>: Filename of script relative to http root (*)</li>
<li><code>REQUEST_METHOD</code>: HTTP request method, one of:<ul>
<li>ERROR</li>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
<li>PUT</li>
<li>DELETE</li>
<li>TRACE</li>
<li>OPTIONS</li>
<li>CONNECT</li>
</ul>
</li>
<li><code>REQUEST_URI</code>: The request URI, including query string</li>
<li><code>SERVER_ADDR</code>: Server IP address</li>
<li><code>REMOTE_ADDR</code>: Client IP address</li>
<li><code>SERVER_PORT</code>: Port of the web server</li>
<li><code>REMOTE_PORT</code>: Port used by the client</li>
<li><code>HTTPS</code>: String should be "on" when the page has been accessed through a secure (HTTPS) connection, otherwise undefined (most probably empty).</li>
<li><code>SERVER_NAME</code>: The server's FQDN (fully qualified domain name). (*)</li>
<li><code>SERVER_SOFTWARE</code>: The web server software, such as "Apache" or "NAWA Development Web Server".</li>
<li><code>BASE_URL</code>: The URL of the current request, starting with <code><a href="http://">http://</a></code> or <code><a href="https://">https://</a></code>, and including the hostname (and port, if necessary), but not the request URI.</li>
<li><code>FULL_URL_WITH_QS</code>: The full URL of the current request, starting with <code><a href="http://">http://</a></code> or <code><a href="https://">https://</a></code>, including the query string.</li>
<li><code>FULL_URL_WITHOUT_QS</code>: Same as <code>FULL_URL_WITH_QS</code>, but without the query string.</li>
</ul>
<p>When using the FastCGI request handler, additional FastCGI parameters are accessible using their original key, unless they start with <code>HTTP_</code> (then, they are interpreted as HTTP request headers, see next section).</p>
<h2>Availability of request headers</h2>
<p>Most HTTP request headers are available as environment variables (with lowercase keys), for example:</p>
<ul>
<li><code>host</code>: Requested server hostname</li>
<li><code>user-agent</code>: User agent string (of the client's web browser)</li>
<li><code>accept</code>: Content types accepted by the client</li>
<li><code>accept-charset</code>: Character sets accepted by the client</li>
<li><code>accept-language</code>: Content languages preferred and understood by the client.</li>
<li><code>authorization</code>: HTTP authorization string</li>
<li><code>referer</code>: Referral URL</li>
<li><code>content-type</code>: Content type of data from client</li>
<li><code>if-modified-since</code>: Unix timestamp sent by the client (to indicate that a full response is only necessary if the requested content has been modified since this date)</li>
</ul>
<p>All request headers are available when using the HTTP request handler. When using the FastCGI request handler, all request headers which are available as FastCGI parameters with standardized keys (e.g., <code>HTTP_MY_HEADER</code> for the header <code>my-header</code>) are accessible this way. Depending on your web server software, you might need to manually map custom headers to FastCGI parameters. Refer to your web server's docs for instructions.</p>
<h1>GET, POST, and COOKIE</h1>
<p>You can access the GET, POST, and COOKIE variables through the <code>[]</code> operator of <code>connection.request().get()</code>, <code>connection.request().post()</code>, and <code>connection.request().cookie()</code>, respectively. If the variable exists more than once (which is possible), the operator will only access one definition (usually the first one). Example:</p>
<div class="fragment"><div class="line">std::string firstName = connection.request().post()[<span class="stringliteral">&quot;first_name&quot;</span>];</div>
</div><!-- fragment --><p>To find out how many definitions exist for the name "variable", use <br  />
 <code>connection.request().post().count("variable")</code>.</p>
<p>If there are multiple definitions, you can use <code>connection.request().post().getVector("variable")</code> to get a vector of strings. Alternatively, you can get a multimap of all key-value pairs via <code>connection.request().post().getMultimap()</code>. You can also iterate through the GET, POST, or COOKIE data, for example:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span> &amp;e: connection.request().post()) {</div>
<div class="line">    connection.responseStream() &lt;&lt; <span class="stringliteral">&quot;&lt;p&gt;POST[&quot;</span> &lt;&lt; e.first &lt;&lt; <span class="stringliteral">&quot;] = &quot;</span> &lt;&lt; e.second &lt;&lt; <span class="stringliteral">&quot;&lt;/p&gt;&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>To find out if anything has been submitted via POST at all, you can just use <code>connection.request().post()</code> as a boolean value:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (connection.request().post()) {</div>
<div class="line">    <span class="comment">// do something</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>All of the above also applies to GET and COOKIE variables. A detailed documentation of the methods is available here: <code>nawa::Request::GPC</code>. An example can be found in <code><a class="el" href="contactform_8cpp.html" title="A simple contact form application using nawa.">examples/contactform.cpp</a></code>.</p>
<h2>Special methods for POST data</h2>
<p>POST is not limited to key-value pairs, the browser might also send files, or something completely else. You can access the content type (as a string) via <code>connection.request().post().getContentType()</code>.</p>
<p>If files have been submitted (content type <code>multipart/form-data</code>), you can access them through <code>connection.request().post().getFile("key")</code> (see <code>nawa::Request::Post::getFile()</code>). For multiple files with the same name, <code>nawa::Request::Post::getFileVector()</code> can be used, or the full multimap can be accessed via <code>nawa::Request::Post::getFileMultimap()</code>.</p>
<p>Files are represented as <code><a class="el" href="classnawa_1_1File.html">nawa::File</a></code> objects, have a look at the documentation of that class to see how to retrieve the file and its meta data.</p>
<p>To access the raw POST data as a string, you can use <br  />
 <code>connection.request().post().getRawHttp()</code> depending on the config value <code>raw_access</code> in the <code>[post]</code> section. By default, the value is <code>nonstandard</code>, meaning you can access the raw data only if it doesn't contain standard content types (key-value pairs or files). You can, however, set it to <code>always</code>, but keep in mind that this leads to a higher memory consumption (as the POST data is always copied). If you don't need this feature at all, consider setting it to <code>never</code>.</p>
<p>For an example on advanced POST features such as file handling, have a look at <code>tests/gpctest.cpp</code>.</p>
<h2>Setting cookies</h2>
<p>For setting cookies, i.e., sending them with your response and requesting the browser to save them and send them back with its requests, there is the method <code>connection.setCookie()</code> (<code><a class="el" href="classnawa_1_1Connection.html#a3c31581990a0eb1742bed6392e21133b">nawa::Connection::setCookie()</a></code>).</p>
<p>You can use this method in the following way to create a cookie <em>with default attributes</em> (since v0.2, see below):</p>
<div class="fragment"><div class="line">connection.setCookie(<span class="stringliteral">&quot;myCookie&quot;</span>, <span class="stringliteral">&quot;cookie_content&quot;</span>);</div>
</div><!-- fragment --><p>A cookie does not only contain a value, but a lot of attributes. To set a cookie with custom attributes, you can create a <code><a class="el" href="classnawa_1_1Cookie.html">nawa::Cookie</a></code> object and set the attributes accordingly, if desired.</p>
<p>All attributes, except for the actual content string, have default values that are determined by the cookie policy, which you can set by creating a <code><a class="el" href="classnawa_1_1Cookie.html">nawa::Cookie</a></code> object with the desired attributes, and passing it to <code>connection.setCookiePolicy()</code> (<code><a class="el" href="classnawa_1_1Connection.html#a051341aa63ae9ebf7268f11d50f26212">nawa::Connection::setCookiePolicy()</a></code>) &ndash; all cookies created for the current response from that point will have these default attributes, unless they are overridden.</p>
<p>The default values for the <code>expires</code>, <code>maxAge</code>, <code>domain</code>, <code>path</code>, and <code>sameSite</code> attributes are used only if the corresponding members of the <code><a class="el" href="classnawa_1_1Cookie.html">nawa::Cookie</a></code> object are not set. For the <code>secure</code> and <code>httpOnly</code> attributes, the strongest value (<code>true</code>) wins (i.e., these attributes are set if either the actual Cookie object or the cookie policy demands this).</p>
<p>After defining your <code><a class="el" href="classnawa_1_1Cookie.html">nawa::Cookie</a></code> object, pass it to <code>connection.setCookie()</code>:</p>
<div class="fragment"><div class="line"><a class="code" href="classnawa_1_1Cookie.html">nawa::Cookie</a> myCookie(<span class="stringliteral">&quot;cookie_content&quot;</span>);</div>
<div class="line"><span class="comment">// set desired attributes ...</span></div>
<div class="line">connection.setCookie(<span class="stringliteral">&quot;myCookie&quot;</span>, myCookie);</div>
<div class="ttc" id="aclassnawa_1_1Cookie_html"><div class="ttname"><a href="classnawa_1_1Cookie.html">nawa::Cookie</a></div><div class="ttdef"><b>Definition:</b> <a href="Cookie_8h_source.html#l00036">Cookie.h:36</a></div></div>
</div><!-- fragment --><p><b>Please note:</b> This method won't have any effect after the response has been flushed at least once (using <code>connection.flushResponse()</code>).</p>
<h3>Unsetting cookies</h3>
<p>You can remove a cookie from the cookie map, so it won't be sent with your request, by using <code>connection.unsetCookie("key")</code> (<code><a class="el" href="classnawa_1_1Connection.html#aac519a967a02664239309fb896c60faa">nawa::Connection::unsetCookie()</a></code>). Please note that this won't remove a cookie from the user's browser, it will just undo the <code>setCookie</code> operation (only works before flushing the response, of course).</p>
<p>Actually removing a cookie from the visitor's browser is not specified in HTTP. To delete the contents of a cookie, set the cookie to an empty string. You can also try to set the expiry date to a date in the past, which might delete the cookie in some browsers.</p>
<h1>Setting HTTP status and response headers</h1>
<p>To set the HTTP status, e.g. to 404 ("Not found"), use <br  />
 <code>connection.setStatus(uint status)</code> (<code><a class="el" href="classnawa_1_1Connection.html#a330e2f885ac364225340718a1a520404">nawa::Connection::setStatus()</a></code>).</p>
<p>HTTP response headers can be set via <code>connection.setHeader(string key, string value)</code> (<code><a class="el" href="classnawa_1_1Connection.html#a4c261bc0ca0d0cc59093e680985ac68e">nawa::Connection::setHeader()</a></code>), and unset via <code>connection.unsetHeader(string key)</code> (<code><a class="el" href="classnawa_1_1Connection.html#a10caec22ea8c1c31aa4da7de182e740d">nawa::Connection::unsetHeader()</a></code>).</p>
<p>Both methods can only be used before flushing the response. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
